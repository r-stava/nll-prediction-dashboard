# -*- coding: utf-8 -*-
"""nll machine learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oMRiaWCN88MI5bTMrypYob_aV8Lj3m5d

Loading Data
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd

# Load the states excel file
states_df = pd.read_excel('states.xlsx')

# Load vacancy rates excel file
vacancy_rates_df = pd.read_excel('vacancy rates.xlsx')

# Load rental rates excel file
rental_rates_df = pd.read_excel('rental rates.xlsx')

# Load home value rates excel file
home_value_rates_df = pd.read_excel('home value rates.xlsx')

# Displaying the first few rows of each dataframe to understand their structure
print("States Data:")
print(states_df.head())
print("\nVacancy Rates Data:")
print(vacancy_rates_df.head())
print("\nRental Rates Data:")
print(rental_rates_df.head())
print("\nHome Value Rates Data:")
print(home_value_rates_df.head())

# Merge rental rates and states
rental_rates_df = rental_rates_df.merge(states_df, left_on='State Abbr', right_on='State Abbr', how='left')

# Merge home value rates and states
home_value_rates_df = home_value_rates_df.merge(states_df, left_on='State Abbr', right_on='State Abbr', how='left')

# Preview the merged data
print("\nMerged Rental Rates Data:")
print(rental_rates_df.head())
print("\nMerged Home Value Rates Data:")
print(home_value_rates_df.head())

"""Pre-Processing Data"""

# Step 2: Preprocess the data

# Merge state names with abbreviations to help match counties with states
states_df = pd.read_excel('states.xlsx')
rental_rates_df = pd.read_excel('rental rates.xlsx')
home_value_rates_df = pd.read_excel('home value rates.xlsx')
vacancy_rates_df = pd.read_excel('vacancy rates.xlsx')

# Merge the states dataframe with rental rates and home value rates
rental_rates_df = rental_rates_df.merge(states_df, left_on='State Abbr', right_on='State Abbr', how='left')
home_value_rates_df = home_value_rates_df.merge(states_df, left_on='State Abbr', right_on='State Abbr', how='left')

# Display the first few rows of data to make sure it merged properly
print(rental_rates_df.head())
print(home_value_rates_df.head())

# Handle missing values - remove rows with missing values for now
rental_rates_df.dropna(inplace=True)
home_value_rates_df.dropna(inplace=True)
vacancy_rates_df.dropna(inplace=True)

# Allow user to input county name
selected_county = input('Enter the name of the county you are interested in: ')

# Filter data for the selected county and get the corresponding state
filtered_rental_rates = rental_rates_df[rental_rates_df['County'] == selected_county]
filtered_home_value_rates = home_value_rates_df[home_value_rates_df['County'] == selected_county]
state_for_vacancy = filtered_rental_rates['State Name'].values[0]  # Get the state name from rental data

# Filter vacancy rates for the corresponding state
filtered_vacancy_rates = vacancy_rates_df[vacancy_rates_df['state'] == state_for_vacancy]

# Ensure time series data is in the right format

# For rental rates, set the time series index as the date columns (from the 5th column onwards)
rental_time_series = filtered_rental_rates.set_index('County').drop(columns=['State Abbr', 'State Name', 'StateCodeFIPS', 'MunicipalCodeFIPS'])

# For home value rates, set the time series index as the date columns (from the 5th column onwards)
home_value_time_series = filtered_home_value_rates.set_index('County').drop(columns=['State Abbr', 'State Name', 'StateCodeFIPS', 'MunicipalCodeFIPS'])

# For vacancy rates, treat it as yearly data and set the index as 'State'
vacancy_time_series = filtered_vacancy_rates.set_index('state')

# Print a summary of the data
print("Rental rates time series for", selected_county)
print(rental_time_series.head())

print("Home value rates time series for", selected_county)
print(home_value_time_series.head())

print("Vacancy rates time series for the state of", state_for_vacancy)
print(vacancy_time_series.head())

"""Time Series Algorithms | Seasonal ARIMA | Vacancy Rate"""

# Step 1: Prepare the vacancy time series data

import pandas as pd
import matplotlib.pyplot as plt

# Assuming the previous data loading steps are already done

# Transpose the vacancy rate data and drop the 'state' column
vacancy_time_series = filtered_vacancy_rates.drop(columns=['state']).T  # Drop 'state' and transpose to get years as index

# Rename the column for clarity
vacancy_time_series.columns = ['Vacancy Rate']

# Convert the index (which should now be years) to datetime format
vacancy_time_series.index = pd.to_datetime(vacancy_time_series.index, format='%Y', errors='coerce')

# Remove any invalid dates that were not converted properly
vacancy_time_series = vacancy_time_series.dropna()

# Visualize the vacancy rate time series data
print("Vacancy Rate Time Series Data for the State:", state_for_vacancy)
print(vacancy_time_series.head())

# Plotting the Vacancy Rate Time Series
plt.figure(figsize=(10, 6))
plt.plot(vacancy_time_series.index, vacancy_time_series['Vacancy Rate'], label="Vacancy Rate", marker='o')
plt.title(f"Vacancy Rate Trend for {state_for_vacancy}")
plt.xlabel("Year")
plt.ylabel("Vacancy Rate")
plt.grid(True)
plt.legend()
plt.show()

pip install pmdarima

# Step 1: Prepare the vacancy time series data

import pandas as pd
import matplotlib.pyplot as plt

# Assuming the previous data loading steps are already done

# Transpose the vacancy rate data and drop the 'state' column
vacancy_time_series = filtered_vacancy_rates.drop(columns=['state']).T  # Drop 'state' and transpose to get years as index

# Rename the column for clarity
vacancy_time_series.columns = ['Vacancy Rate']

# Convert the index (which should now be years) to datetime format
vacancy_time_series.index = pd.to_datetime(vacancy_time_series.index, format='%Y', errors='coerce')

# Remove any invalid dates that were not converted properly
vacancy_time_series = vacancy_time_series.dropna()

# Visualize the vacancy rate time series data
print("Vacancy Rate Time Series Data for the State:", state_for_vacancy)
print(vacancy_time_series.head())

# Plotting the Vacancy Rate Time Series
plt.figure(figsize=(10, 6))
plt.plot(vacancy_time_series.index, vacancy_time_series['Vacancy Rate'], label="Vacancy Rate", marker='o')
plt.title(f"Vacancy Rate Trend for {state_for_vacancy}")
plt.xlabel("Year")
plt.ylabel("Vacancy Rate")
plt.grid(True)
plt.legend()
plt.show()

# Import the necessary library
from pmdarima import auto_arima
import matplotlib.pyplot as plt
import numpy as np

# Step 1: Split the data for training and testing
train_data = vacancy_time_series['Vacancy Rate'][:len(vacancy_time_series)-5]
test_data = vacancy_time_series['Vacancy Rate'][-5:]

# Step 2: Fitting SARIMA model
# Set seasonal=True, m=1 (since it's yearly data), and use auto_arima to find the best model
sarima_model = auto_arima(train_data, seasonal=True, m=1, trace=True, stepwise=True, suppress_warnings=True)

# Print the summary of the SARIMA model
print(sarima_model.summary())

# Step 3: Forecasting
n_periods = len(test_data)  # Predict for the length of test data
sarima_forecast = sarima_model.predict(n_periods=n_periods)

# Step 4: Visualize the results
plt.figure(figsize=(10, 6))
plt.plot(np.arange(len(train_data)), train_data, label='Training Data')
plt.plot(np.arange(len(train_data), len(train_data) + len(test_data)), test_data, label='Actual Vacancy Rate')
plt.plot(np.arange(len(train_data), len(train_data) + len(sarima_forecast)), sarima_forecast, label='Predicted Vacancy Rate (SARIMA)', linestyle='--')
plt.title('Actual vs Predicted Vacancy Rate (SARIMA)')
plt.xlabel('Year')
plt.ylabel('Vacancy Rate')
plt.legend()
plt.grid(True)
plt.show()

# Calculate and print error metrics
mse = np.mean((sarima_forecast - test_data)**2)
mae = np.mean(np.abs(sarima_forecast - test_data))
print(f"Mean Squared Error (MSE): {mse}")
print(f"Mean Absolute Error (MAE): {mae}")

# Step 1: Split the data for training and testing
train_data = vacancy_time_series['Vacancy Rate'][:len(vacancy_time_series)-5]
test_data = vacancy_time_series['Vacancy Rate'][-5:]

# Step 2: Fitting SARIMA model
# Set seasonal=True, m=1 (since it's yearly data), and use auto_arima to find the best model
sarima_model = auto_arima(train_data, seasonal=True, m=1, trace=True, stepwise=True, suppress_warnings=True)

# Print the summary of the SARIMA model
print(sarima_model.summary())

# Step 3: Forecasting for 3, 5, and 10 years
forecast_years = [3, 5, 10]
forecasts = {}

# Forecast for each of the years (3, 5, and 10)
for years in forecast_years:
    forecast = sarima_model.predict(n_periods=years)
    forecasts[years] = forecast[-1]  # Get the last prediction in the forecast range

# Visualize the test data and SARIMA prediction
n_periods = len(test_data)
sarima_forecast = sarima_model.predict(n_periods=n_periods)

# Step 4: Visualize the actual vs predicted vacancy rates (for the test set)
plt.figure(figsize=(10, 6))
plt.plot(np.arange(len(train_data)), train_data, label='Training Data')
plt.plot(np.arange(len(train_data), len(train_data) + len(test_data)), test_data, label='Actual Vacancy Rate')
plt.plot(np.arange(len(train_data), len(train_data) + len(sarima_forecast)), sarima_forecast, label='Predicted Vacancy Rate (SARIMA)', linestyle='--')
plt.title('Actual vs Predicted Vacancy Rate (SARIMA)')
plt.xlabel('Year')
plt.ylabel('Vacancy Rate')
plt.legend()
plt.grid(True)
plt.show()

# Calculate and print error metrics
mse = np.mean((sarima_forecast - test_data)**2)
mae = np.mean(np.abs(sarima_forecast - test_data))
print(f"Mean Squared Error (MSE): {mse}")
print(f"Mean Absolute Error (MAE): {mae}")

# Print the forecasts for 3, 5, and 10 years
print(f"Vacancy Rate Prediction in 3 years: {forecasts[3]:.2f}")
print(f"Vacancy Rate Prediction in 5 years: {forecasts[5]:.2f}")
print(f"Vacancy Rate Prediction in 10 years: {forecasts[10]:.2f}")

"""Time Series Algorithms | Prophet | Home Value Rate and Rental Rate"""

pip install prophet

# Step 2.1: Prepare rental rates data for Prophet
# Transpose to get dates as rows instead of columns
rental_data = filtered_rental_rates.T

# The columns are now the dates, we need to rename the index to 'ds' (date) and the rate values to 'y'
rental_data = rental_data.rename_axis('ds').reset_index()  # Reset index to get the dates as a column
rental_data.columns = ['ds', 'y']  # Prophet expects 'ds' (date) and 'y' (value)

# Print the first few rows to make sure the structure is correct
print(rental_data.head())

# Step 2.2: Prepare home value rates data for Prophet
# Transpose to get dates as rows instead of columns
home_value_data = filtered_home_value_rates.T

# The columns are now the dates, we need to rename the index to 'ds' (date) and the rate values to 'y'
home_value_data = home_value_data.rename_axis('ds').reset_index()  # Reset index to get the dates as a column
home_value_data.columns = ['ds', 'y']  # Prophet expects 'ds' (date) and 'y' (value)

# Print the first few rows to make sure the structure is correct
print(home_value_data.head())

from prophet import Prophet
import pandas as pd

# Step 3.1: Prepare the data for Prophet
# Select only the date columns and rental rates for the selected county
# Drop unnecessary columns
rental_time_series = filtered_rental_rates.drop(columns=['County', 'State Abbr', 'State Name', 'StateCodeFIPS', 'MunicipalCodeFIPS'])
rental_time_series = rental_time_series.T  # Transpose to get dates as index
rental_time_series.columns = ['rental_rate']  # Rename the column for clarity

# Ensure index is treated as a datetime index
rental_time_series.index = pd.to_datetime(rental_time_series.index)

# Step 3.2: Format the data for Prophet
# Prophet expects a dataframe with 'ds' as the date column and 'y' as the target value
rental_data = rental_time_series.reset_index()  # Reset index to make date a column
rental_data.columns = ['ds', 'y']  # Rename columns to fit Prophet's requirements

# Step 3.3: Fit the Prophet model
rental_model = Prophet()
rental_model.fit(rental_data)

# Step 3.4: Create a dataframe to hold future dates for prediction (3, 5, and 10 years)
future_dates = rental_model.make_future_dataframe(periods=10 * 12, freq='M')  # 10 years of monthly data

# Step 3.5: Predict future rental rates
rental_forecast = rental_model.predict(future_dates)

# Step 3.6: Visualize the forecast
rental_model.plot(rental_forecast)
plt.title('Rental Rate Prediction (Prophet)')
plt.xlabel('Year')
plt.ylabel('Rental Rate')
plt.show()

# Print future predictions for 3, 5, and 10 years from now
future_predictions = rental_forecast[['ds', 'yhat']].tail(10 * 12)  # Last 10 years of prediction data
print(future_predictions)

from prophet import Prophet
import pandas as pd

# Step 4.1: Prepare the data for Prophet
# Select only the date columns and home value rates for the selected county
home_value_data = filtered_home_value_rates.T  # Transpose to get dates as rows
home_value_data.columns = ['Home Value Rate']  # Rename the column

# Prepare the dataframe in Prophet's format
home_value_data.reset_index(inplace=True)
home_value_data.columns = ['ds', 'y']  # Prophet expects 'ds' as the date and 'y' as the target

# Remove any non-date rows (such as the header row)
home_value_data = home_value_data[~home_value_data['ds'].isin(['County', 'State Abbr', 'State Name', 'StateCodeFIPS', 'MunicipalCodeFIPS'])]

# Convert 'ds' to datetime format
home_value_data['ds'] = pd.to_datetime(home_value_data['ds'], errors='coerce')
home_value_data.dropna(inplace=True)  # Drop any rows where date conversion failed

# Step 4.2: Initialize the Prophet model
home_value_model = Prophet()

# Step 4.3: Fit the Prophet model
home_value_model.fit(home_value_data)

# Step 4.4: Create a dataframe to hold future dates for prediction (3, 5, and 10 years)
future_dates_home_value = home_value_model.make_future_dataframe(periods=120, freq='M')  # 120 months (10 years)

# Step 4.5: Make predictions
home_value_forecast = home_value_model.predict(future_dates_home_value)

# Step 4.6: Visualize the predictions
home_value_model.plot(home_value_forecast)
plt.title(f"Home Value Rate Forecast for {selected_county}")
plt.ylabel("Home Value Rate")
plt.xlabel("Year")
plt.grid(True)
plt.show()

# Step 4.7: Print out the future predictions for 3, 5, and 10 years
print(home_value_forecast[['ds', 'yhat']].tail(120))  # Last 10 years' forecast

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, mean_absolute_error

# Step 1: Visualize the forecasts for both rental and home value rates
def visualize_forecast(forecast, title, y_label):
    plt.figure(figsize=(10, 6))
    plt.plot(forecast['ds'], forecast['yhat'], label='Forecasted')
    plt.title(title)
    plt.ylabel(y_label)
    plt.xlabel('Year')
    plt.grid(True)
    plt.legend()
    plt.show()

# Visualize Rental Rate Forecast
visualize_forecast(rental_forecast, f'Rental Rate Forecast for {selected_county}', 'Rental Rate')

# Visualize Home Value Rate Forecast
visualize_forecast(home_value_forecast, f'Home Value Rate Forecast for {selected_county}', 'Home Value Rate')

# Step 2: Generate Predictions for 3, 5, and 10 years
def get_predictions(forecast, years):
    future_years = [f"{years} years"]
    forecast_years = forecast[forecast['ds'] >= pd.Timestamp(f"{2024 + years}-01-01")].head(1)  # Change year here
    predictions = forecast_years[['ds', 'yhat']]
    return predictions

# Rental Rate Predictions
rental_rate_3_years = get_predictions(rental_forecast, 3)
rental_rate_5_years = get_predictions(rental_forecast, 5)
rental_rate_10_years = get_predictions(rental_forecast, 10)

# Home Value Rate Predictions
home_value_rate_3_years = get_predictions(home_value_forecast, 3)
home_value_rate_5_years = get_predictions(home_value_forecast, 5)
home_value_rate_10_years = get_predictions(home_value_forecast, 10)

# Print Predictions
print("Rental Rate Predictions (3, 5, and 10 years):")
print(rental_rate_3_years)
print(rental_rate_5_years)
print(rental_rate_10_years)

print("\nHome Value Rate Predictions (3, 5, and 10 years):")
print(home_value_rate_3_years)
print(home_value_rate_5_years)
print(home_value_rate_10_years)

# Step 3: Evaluate the accuracy of both models
def evaluate_accuracy(forecast, actual):
    predicted = forecast['yhat'][-len(actual):]
    mse = mean_squared_error(actual, predicted)
    mae = mean_absolute_error(actual, predicted)
    return mse, mae

# Assuming `test_data` has the actual values for the test set (from Step 1)
rental_mse, rental_mae = evaluate_accuracy(rental_forecast, test_data)
home_value_mse, home_value_mae = evaluate_accuracy(home_value_forecast, test_data)

# Print accuracy metrics
print(f"\nRental Rate Prediction Accuracy: MSE={rental_mse}, MAE={rental_mae}")
print(f"Home Value Rate Prediction Accuracy: MSE={home_value_mse}, MAE={home_value_mae}")

"""Dashboard | Printing the predictions for vacancy rate, home value rate and rental rate"""

# Step 1: Install necessary libraries if not already installed
pip install streamlit matplotlib prophet pmdarima

# Step 2: Import necessary libraries
import streamlit as st
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Create the Streamlit app
st.title('Real Estate Market Prediction Dashboard')

# User Input: Select County
county_input = st.text_input("Enter the County Name for Prediction (e.g., 'Los Angeles County')", "")

# Step 4: Display Vacancy Rate Prediction
st.subheader('Vacancy Rate Prediction')

# Check if user has entered a county name
if county_input:
    st.write(f"Predictions for {county_input}")

    # Assuming you have variables `vacancy_forecast` from SARIMA and functions for visualizing and predictions
    st.write("**Vacancy Rate Forecast**")

    # Display the forecast plot
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.plot(vacancy_time_series.index, vacancy_time_series['Vacancy Rate'], label='Historical Data', marker='o')
    ax.plot(np.arange(len(vacancy_time_series.index), len(vacancy_time_series.index) + len(forecast_years)),
            forecasts.values(), label='Predicted Vacancy Rate', linestyle='--')
    ax.set_title(f"Vacancy Rate Trend for {county_input}")
    ax.set_xlabel("Year")
    ax.set_ylabel("Vacancy Rate")
    ax.grid(True)
    ax.legend()
    st.pyplot(fig)

    # Print Predictions
    st.write(f"Vacancy Rate Prediction for 3 years: {forecasts[3]:.2f}")
    st.write(f"Vacancy Rate Prediction for 5 years: {forecasts[5]:.2f}")
    st.write(f"Vacancy Rate Prediction for 10 years: {forecasts[10]:.2f}")

# Step 5: Display Rental Rate Prediction
st.subheader('Rental Rate Prediction')

# Adjust the number of years to predict based on future dates
years_to_predict = [3, 5, 10]
rental_forecast_3_years = rental_forecast.iloc[144 + years_to_predict[0]] if len(rental_forecast) > 144 + years_to_predict[0] else None
rental_forecast_5_years = rental_forecast.iloc[144 + years_to_predict[1]] if len(rental_forecast) > 144 + years_to_predict[1] else None
rental_forecast_10_years = rental_forecast.iloc[144 + years_to_predict[2]] if len(rental_forecast) > 144 + years_to_predict[2] else None

# Plot the forecast for rental rates (from Prophet model)
if rental_forecast_3_years is not None:
    st.write("**Rental Rate Forecast**")

    fig2, ax2 = plt.subplots(figsize=(10, 6))
    ax2.plot(rental_forecast['ds'], rental_forecast['yhat'], label='Forecasted', color='blue')
    ax2.set_title(f'Rental Rate Forecast for {county_input}')
    ax2.set_xlabel('Year')
    ax2.set_ylabel('Rental Rate')
    ax2.grid(True)
    st.pyplot(fig2)

    # Print future predictions for 3, 5, and 10 years
    if rental_forecast_3_years is not None:
        st.write(f"Rental Rate Prediction in 3 years: {rental_forecast_3_years['yhat']:.2f}")
    if rental_forecast_5_years is not None:
        st.write(f"Rental Rate Prediction in 5 years: {rental_forecast_5_years['yhat']:.2f}")
    if rental_forecast_10_years is not None:
        st.write(f"Rental Rate Prediction in 10 years: {rental_forecast_10_years['yhat']:.2f}")

# Step 6: Display Home Value Rate Prediction
st.subheader('Home Value Rate Prediction')

# Adjust the number of years to predict for home value rates
home_value_forecast_3_years = home_value_forecast.iloc[144 + years_to_predict[0]] if len(home_value_forecast) > 144 + years_to_predict[0] else None
home_value_forecast_5_years = home_value_forecast.iloc[144 + years_to_predict[1]] if len(home_value_forecast) > 144 + years_to_predict[1] else None
home_value_forecast_10_years = home_value_forecast.iloc[144 + years_to_predict[2]] if len(home_value_forecast) > 144 + years_to_predict[2] else None

# Plot the forecast for home value rates (from Prophet model)
if home_value_forecast_3_years is not None:
    st.write("**Home Value Rate Forecast**")

    fig3, ax3 = plt.subplots(figsize=(10, 6))
    ax3.plot(home_value_forecast['ds'], home_value_forecast['yhat'], label='Forecasted', color='green')
    ax3.set_title(f'Home Value Rate Forecast for {county_input}')
    ax3.set_xlabel('Year')
    ax3.set_ylabel('Home Value Rate')
    ax3.grid(True)
    st.pyplot(fig3)

    # Print future predictions for 3, 5, and 10 years
    if home_value_forecast_3_years is not None:
        st.write(f"Home Value Rate Prediction in 3 years: {home_value_forecast_3_years['yhat']:.2f}")
    if home_value_forecast_5_years is not None:
        st.write(f"Home Value Rate Prediction in 5 years: {home_value_forecast_5_years['yhat']:.2f}")
    if home_value_forecast_10_years is not None:
        st.write(f"Home Value Rate Prediction in 10 years: {home_value_forecast_10_years['yhat']:.2f}")

# Step 7: Add Footer
st.write("Real Estate Market Predictions Powered by SARIMA and Prophet Models")
